---
title: Symbolic Operations and CLBM
author: Grzegorz Gruszczynski
header-includes:
   - \usepackage{bbm}
   - \usepackage{amsmath, amsthm, amsfonts, amssymb}
date: "February 27, 2019"
output: html_document
---

# Symbolic Operations and CLBM

!!! warning "Before start, it is assumed that the reader is already familiar with:"
		* Basic model creation in the TCLB code, see [first tutorial](/tutorials/model-development/1.-finite-difference-wave-equation)
    * Basics of LB physics, see [SRT LBM](/tutorials/model-development/2.-D2Q9-Single-Relexation-Time) and [DDF Heat Transfer](/tutorials/model-development/4.-D2Q9-HeatTransfer)

!!! success "We will cover following topics:"
    * Symbolic computations (within) TCLB.
    * Heat transfer on D2Q9 lattice using Central Moments (CM) a.k.a. Cascaded LBM.

## Notion of moments

The raw and central moments are introduced based on the work of Geier et al. [^5] as,

$$ k_{mn} = \sum_{\alpha}(e_{\alpha x})^m ( e_{\alpha y})^n \Psi_{\alpha} $$

while the central moments are calculated in a moving reference frame i.e., with respect to the fluid velocity:
$$ \tilde{k}_{mn} = \sum_{\alpha} ( e_{\alpha x} - u_x)^m ( e_{\alpha y} - u_y)^n \Psi_{\alpha} $$

where \( \Psi_{\alpha} \) is the distribution function of interest (either hydrodynamic or phase field).

Alternatively, formerly equations can be expressed by matrix transformations [^1][^2][^3][^4].
Raw moments are obtained from distribution functions through \( \boldsymbol{\Upsilon} = \mathbb{M} \boldsymbol{g} \), while central moments are derived from raw moments by \( \boldsymbol{\tilde{\Upsilon}}= \mathbb{N} \boldsymbol{\Upsilon} \). 
It is important to notice that \( \mathbb{M} \)is a fixed matrix while \( \mathbb{N} \) depends on the fluid velocity, $\textbf{u}$. 
The form of the matrices can be found 
[here](https://github.com/CFD-GO/TCLB_tools/blob/master/Python/symbolic_tools/SymbolicCollisions/core/cm_symbols.py).

The resulting order of the central moments is,
$$
\boldsymbol{\tilde{\Upsilon}} = 
[\tilde{k}_{00}, \tilde{k}_{10}, \tilde{k}_{01}, \tilde{k}_{20}, \tilde{k}_{02}, \tilde{k}_{11}, \tilde{k}_{21}, \tilde{k}_{12}, \tilde{k}_{22}]^\top.
$$

# Model Creation in TCLB

## Dynamics.R

Take the one from [D2Q9 Heat Transfer tutorial](/tutorials/model-development/4.-D2Q9-HeatTransfer) 
and add a new node type `AddNodeType("CM","COLLISION")`, since we are going to implement a new collision kernel.

## Dynamics.c

First we have to load R symbols.

```c
<?R
	source("conf.R") 
	source("lib/boundary.R")
	c_header();

# Creating variables for symbolic computations
	f = PV(DensityAll$name[DensityAll$group=="f"])
	h = PV(DensityAll$name[DensityAll$group=="h"])
	rho =  PV("rho")
	u = PV(c("ux","uy"))
	rhoT = PV("rhoT")

# Extracting velocity set
	U = d2q9

?>
```

### Macroscopic Quantities

Now we can perform symbolic operations with `R`:

```c
CudaDeviceFunction real_t getRho(){
	return <?R C(sum(f)) ?>;
}

CudaDeviceFunction real_t getT(){
	return (<?R C(sum(h)) ?>)/(<?R C(sum(f)) ?>);
}
    
CudaDeviceFunction vector_t getRawU(){
	real_t d = getRho();
	vector_t u;
<?R C(PV(c("u.x","u.y", "u.z")), f %*% U) ?>
	u.x /= d;
	u.y /= d;
	u.z = 0;
	return u;
}

CudaDeviceFunction vector_t getU()
{
	real_t localTemperature = getT();
	vector_t u = getRawU();
	real_t m00 = getRho();
	vector_t Force = getForce(localTemperature, m00);
	u.x += Force.x/(2*m00);
	u.y += Force.y/(2*m00);
	u.z = 0;
	return u;
}
```

### Collision

```c
CudaDeviceFunction void CollisionCM()
{
	real_t localTemperature = getT();
	real_t m00 = getRho();

	vector_t Force = getForce(localTemperature, m00);
	vector_t u = getRawU();
	u.x += Force.x/(2*m00);
	u.y += Force.y/(2*m00);

	// add Darcy force to stop flow within solid regions
	if ((NodeType & NODE_ADDITIONALS) == NODE_Solid) 
	{
		vector_t uDarcyStoper = get_uDarcyStoper(m00,  u);
		Force.x += uDarcyStoper.x;
		Force.y += uDarcyStoper.y;
	} 

	relax_and_collide_hydro_with_F(f, omega_nu, u, Force);	
	// if ((NodeType & NODE_ADDITIONALS) == NODE_HeaterDirichletTemperature) {
	// 	// case I - skip collision, just impose d_rhoTeq
	// 	real_t d_rhoT = m00*InitTemperature;
	// 	real_t h_source[9];
	// 	set_eq(h_source, d_rhoT, u); 

	// 	for (int i = 0; i < 9; i++) {
	// 		h[i] = h_source[i];
	// 	}
	// }
	// else{
	// 	relax_and_collide_ADE(h, omega_k, u);
	// }


	// equilibrium scheme for BC
	// see chapter 5.3.4.2, eq 5.34, p191 from 'The Lattice Boltzmann Method: Principles and Practice'
	// by T. Krüger, H. Kusumaatmaja, A. Kuzmin, O. Shardt, G. Silva, E.M. Viggen

	relax_and_collide_ADE(h, omega_k, u);

	if ((NodeType & NODE_ADDITIONALS) == NODE_HeaterDirichletTemperature) 
	{
		// we are after collision in this if-scope {}
		// case II - for omega_k = 1 is the same as case I, however for different omega_k shall be a bit better
		real_t d_rhoT = m00*(InitTemperature - localTemperature);
		real_t h_source[9];
		set_eq(h_source, d_rhoT, u);

		for (int i = 0; i < 9; i++) {
			h[i] += h_source[i];
		}
	}

	if ((NodeType & NODE_ADDITIONALS) == NODE_HeaterNeumannHeatFlux) 
	{
		// TCLB is smart enough to distiguish values prescribed it batch.xml like
		// InitTemperature-dirichlet_region="123"
		// InitTemperature-neumann_heater_region="456"
		real_t d_rhoT = m00*InitTemperature;  
		real_t h_source[9];
		set_eq(h_source, d_rhoT, u); 
		for (int i = 0; i < 9; i++) {
			h[i] += h_source[i];}
	}
}
```

### Symbolic Operations with python

Although it is possible to inject python snippets using `<?python />` within TCLB code, we will run the symbolic calculations in PyCharm enviroment then copy-paste the output.
Clone the repository containing TCLB tools.

```bash
git clone https://github.com/CFD-GO/TCLB_tools.git
```

Then open the `TCLB_tools/Python/symbolic_tools/` directory in PyCharm.

## References

!!! tip
		A good starting point explaining the 'zoo' of various LBM models is a modern (2017) book
		'The Lattice Boltzmann Method: Principles and Practice'
		written by  T. Krüger, H. Kusumaatmaja, A. Kuzmin, O. Shardt, G. Silva, E.M. Viggen .

The implementation of the cascaded collision kernel is greatly insipered by the work of Linlin Fei, Kai H. Luo et al.

[^1]: Linlin Fei, Kai Hong Luo, 'Cascaded lattice Boltzmann method for incompressible thermal flows with heat sources and general thermal boundary conditions' Computers and Fluids (2018).

[^2]: Linlin Fei, Kai Hong Luo, Chuandong Lin, Qing Li, 'Modeling incompressible thermal flows using a central-moments-based lattice Boltzmann method' International Journal of Heat and Mass Transfer (2017).

[^3]: Linlin Fei and Kai Hong Luo, 'Consistent forcing scheme in the cascaded lattice Boltzmann method' Physical Review E 96, 053307 (2017).

[^4]: Linlin Fei, Kai H. Luo and Qing Li, 'Three-dimensional cascaded lattice Boltzmann method: Improved implementation and consistent forcing scheme' Physical Review E 97, 053309 (2018)

[^5]: M. Geier, A. Greiner, J. G. Korvink, 'Cascaded digital lattice Boltzmann automata for high Reynolds number flow' Physical Review E - Statistical, Nonlinear, and Soft Matter Physics 73 (2006).